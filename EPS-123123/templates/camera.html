{% extends "base.html" %}
{% load static %}

{% block content %}

    <div class="relative w-full h-screen bg-gray-100">
        <div id="canvas-container" class="w-full h-full block"></div>

        <div class="absolute top-4 left-4 p-4 bg-white/90 rounded-lg shadow-lg backdrop-blur-sm z-10 w-80">
            <h1 class="text-xl font-bold text-gray-800">Control de Misión</h1>

            <div class="flex justify-between items-center mb-4">
                <p class="text-sm text-gray-600">Estado: <span id="status-text" class="font-bold text-blue-600">Esperando...</span></p>

                <label class="inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggle-ai" class="sr-only peer">
                    <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    <span class="ms-3 text-sm font-medium text-gray-900">Activar AI</span>
                </label>
            </div>

            <div class="mt-2 pt-2 border-t border-gray-200 text-[10px] font-mono text-gray-600">
                <p class="font-bold mb-1">Datos en tiempo real:</p>
                <div id="debug-data" class="h-24 overflow-y-auto bg-gray-50 p-1 border rounded">
                    Esperando JSON...
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';
        import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

        // --- CONFIGURACIÓN ---
        const API_URL = "/api/get-pose/";
        let aiEnabled = false;

        // Escena
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf3f4f6);

        // CÁMARA
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 12, 15);

        const renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 0, 0);

        // LUCES
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- CARGA DE MODELOS ---
        const loader = new GLTFLoader();

        // 1. ROOM
        loader.load("{% static 'models/room/scene.glb' %}", function (gltf) {
            const model = gltf.scene;
            model.rotation.x = -Math.PI / 2;
            model.traverse((node) => { if (node.isMesh) node.receiveShadow = true; });
            scene.add(model);
        });

        // --- VARIABLES PERSONAJE ---
        let characterMesh;
        let bones = {};

        const BONE_MAP = {
            rightShoulder: ['RightArm', 'mixamorigRightArm'],
            rightElbow:    ['RightForeArm', 'mixamorigRightForeArm'],
            leftShoulder:  ['LeftArm', 'mixamorigLeftArm'],
            leftElbow:     ['LeftForeArm', 'mixamorigLeftForeArm'],
            rightHip:      ['RightUpLeg', 'mixamorigRightUpLeg'],
            rightKnee:     ['RightLeg', 'mixamorigRightLeg'],
            leftHip:       ['LeftUpLeg', 'mixamorigLeftUpLeg'],
            leftKnee:      ['LeftLeg', 'mixamorigLeftLeg']
        };

        // 2. PERSONAJE
        loader.load("{% static 'models/caracter/personaje.glb' %}", function (gltf) {
            characterMesh = gltf.scene;
            characterMesh.position.set(0, 0, 0);
            characterMesh.scale.set(3, 3, 3);

            characterMesh.traverse((node) => {
                if (node.isMesh) { node.castShadow = true; node.receiveShadow = true; }
                if (node.isBone) {
                    for (const [key, names] of Object.entries(BONE_MAP)) {
                        if (names.some(n => node.name.includes(n))) bones[key] = node;
                    }
                }
            });
            scene.add(characterMesh);
        });

        // --- UI ---
        const toggleAi = document.getElementById('toggle-ai');
        const statusText = document.getElementById('status-text');
        const debugData = document.getElementById('debug-data');

        toggleAi.addEventListener('change', (e) => {
            aiEnabled = e.target.checked;
            statusText.innerText = aiEnabled ? "Conectando..." : "Inactivo";
            statusText.className = aiEnabled ? "font-bold text-green-600" : "font-bold text-gray-600";
        });

        // --- LÓGICA MATEMÁTICA ---

        function updateArm(bone, ptParent, ptChild, isLeftArmOfCharacter) {
            if (!bone || !ptParent || !ptChild) return;

            let dx = ptChild.x - ptParent.x;
            let dy = ptChild.y - ptParent.y;

            // Ajuste de dirección X para que coincida con la vista
            // Si la cámara no es espejo, no necesitamos invertir tanto
            if (!isLeftArmOfCharacter) {
                 dx = -dx;
            }

            const angle = Math.atan2(-dy, dx);

            if (isLeftArmOfCharacter) {
                 bone.rotation.z = angle + Math.PI/2;
                 bone.rotation.x = 0;
            } else {
                 bone.rotation.z = -angle - Math.PI/2;
                 bone.rotation.x = 0;
            }
        }

        function updateLeg(bone, ptParent, ptChild, isLeftLegOfCharacter) {
            if (!bone || !ptParent || !ptChild) return;

            let dx = ptChild.x - ptParent.x;

            if (!isLeftLegOfCharacter) dx = -dx;

            const sensitivity = 2.0;
            bone.rotation.z = -dx * sensitivity;
            bone.rotation.x = 0;
        }

        async function updatePose() {
            if (!aiEnabled || !characterMesh) return;

            try {
                const res = await fetch(API_URL);
                const data = await res.json();

                if (data && data.extremities) {
                    const ex = data.extremities;
                    debugData.innerText = `Nariz Y: ${ex.nose ? ex.nose.y.toFixed(2) : '--'}`;

                    // --- CAMBIO: MAPEO DIRECTO (SIN CRUZAR) ---
                    // Derecha con Derecha, Izquierda con Izquierda

                    // 1. BRAZO DERECHO DEL PERSONAJE (Con tu Derecha)
                    if (bones.rightShoulder && ex.right_shoulder) updateArm(bones.rightShoulder, ex.right_shoulder, ex.right_elbow, false);
                    if (bones.rightElbow && ex.right_elbow)       updateArm(bones.rightElbow, ex.right_elbow, ex.right_wrist, false);

                    // 2. BRAZO IZQUIERDO DEL PERSONAJE (Con tu Izquierda)
                    if (bones.leftShoulder && ex.left_shoulder)  updateArm(bones.leftShoulder, ex.left_shoulder, ex.left_elbow, true);
                    if (bones.leftElbow && ex.left_elbow)        updateArm(bones.leftElbow, ex.left_elbow, ex.left_wrist, true);

                    // 3. PIERNA DERECHA DEL PERSONAJE (Con tu Derecha)
                    if (bones.rightHip && ex.right_hip)      updateLeg(bones.rightHip, ex.right_hip, ex.right_knee, false);

                    // 4. PIERNA IZQUIERDA DEL PERSONAJE (Con tu Izquierda)
                    if (bones.leftHip && ex.left_hip)       updateLeg(bones.leftHip, ex.left_hip, ex.left_knee, true);

                    // 5. POSICIÓN GLOBAL
                    if (ex.left_hip && ex.right_hip) {
                        const hipX = (ex.left_hip.x + ex.right_hip.x) / 2;
                        const targetX = -(hipX - 0.5) * 10;
                        characterMesh.position.x += (targetX - characterMesh.position.x) * 0.1;
                    }
                }
            } catch (e) {
                // console.error(e);
            }
        }

        setInterval(updatePose, 50);

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        animate();
    </script>
{% endblock content %}