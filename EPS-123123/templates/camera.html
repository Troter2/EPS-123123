{% extends "_base.html" %}
{% load static %}

{% block content %}

<div class="relative w-full h-screen bg-gray-100">
    <div id="canvas-container" class="w-full h-full block"></div>
    <div class="absolute top-4 left-4 p-4 bg-white/80 rounded-lg shadow-lg backdrop-blur-sm">
        <h1 class="text-xl font-bold text-gray-800">Church Model Viewer</h1>
        <p class="text-sm text-gray-600">Posición de la iglesia controlada manualmente</p>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    function init() {
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();

        // ---------------------------------------------------------
        // 1. VARIABLES PARA ANIMACIÓN (NUEVO)
        // ---------------------------------------------------------
        let mixer; // El reproductor de animación
        const clock = new THREE.Clock(); // El reloj para sincronizar

        scene.background = new THREE.Color(0xf3f4f6);

        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(5, 5, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;

        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Luces
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Helpers
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);
        const gridHelper = new THREE.GridHelper(20, 20);
        scene.add(gridHelper);

        const loader = new GLTFLoader();

        // --- CARGA DE LA IGLESIA (Mantenemos igual) ---
        const mainModelPath = "{% static 'models/room/scene.glb' %}";
        const churchConfig = { position: { x: 0, y: 0, z: 0 } };

        loader.load(mainModelPath, function (gltf) {
            const model = gltf.scene;
            model.rotation.x = -Math.PI / 2;
            model.traverse(function (node) {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                    if (node.material.metalness > 0.5) {
                        node.material.metalness = 0.2;
                        node.material.roughness = 0.8;
                    }
                }
            });
            model.position.set(churchConfig.position.x, churchConfig.position.y, churchConfig.position.z);
            scene.add(model);
        });

        // ---------------------------------------------------------
        // 2. CARGA DEL PERSONAJE CON ANIMACIÓN
        // ---------------------------------------------------------
        const characterPath = "{% static 'models/caracter/personaje.glb' %}"; // Asegúrate de tener este archivo

        loader.load(characterPath, function (gltf) {
            const character = gltf.scene;

            // Posición 0,0,0 como pediste
            character.position.set(2.5, 0, 2);
            character.scale.set(3, 3, 3); // Ajusta la escala si sale muy grande/pequeño

            character.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });

            scene.add(character);

            // --- LÓGICA DE ANIMACIÓN (NUEVO) ---
            // Verificamos si el archivo trae animaciones
            if (gltf.animations && gltf.animations.length > 0) {
                // Creamos el mixer (el reproductor) vinculado al personaje
                mixer = new THREE.AnimationMixer(character);

                // Sacamos la primera animación de la lista (normalmente es "Idle" o "Walk")
                const clip = gltf.animations[0];

                // Preparamos la acción y le damos play
                const action = mixer.clipAction(clip);
                action.play();

                console.log("Reproduciendo animación:", clip.name);
            } else {
                console.warn("El modelo no tiene animaciones integradas.");
            }

        }, undefined, function (error) {
            console.error('Error personaje:', error);
        });

        window.addEventListener('resize', onWindowResize);

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // ---------------------------------------------------------
            // 3. ACTUALIZAR ANIMACIÓN (NUEVO)
            // ---------------------------------------------------------
            const delta = clock.getDelta(); // Tiempo transcurrido desde el último frame
            if (mixer) {
                mixer.update(delta); // Avanzar la animación
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    }

    init();
</script>
{% endblock content %}