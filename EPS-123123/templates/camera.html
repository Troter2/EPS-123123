{% extends "base.html" %}
{% load static %}

{% block content %}

    <div class="relative w-full h-screen bg-gray-100">
        <div id="canvas-container" class="w-full h-full block"></div>

        <div class="absolute top-4 left-4 p-4 bg-white/90 rounded-lg shadow-lg backdrop-blur-sm z-10 w-80">
            <h1 class="text-xl font-bold text-gray-800">Control de Misión</h1>

            <div class="flex justify-between items-center mb-4">
                <p class="text-sm text-gray-600">Estado: <span id="status-text" class="font-bold text-blue-600">Esperando...</span>
                </p>

                <label class="inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggle-ai" class="sr-only peer">
                    <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    <span class="ms-3 text-sm font-medium text-gray-900">Activar AI</span>
                </label>
            </div>

            <div class="mt-2 pt-2 border-t border-gray-200 text-[10px] font-mono text-gray-600">
                <p class="font-bold mb-1">Datos en tiempo real:</p>
                <div id="debug-data" class="h-24 overflow-y-auto bg-gray-50 p-1 border rounded">
                    Esperando JSON...
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';
        import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

        // --- CONFIGURACIÓN DE MOVIMIENTO ---
        const API_URL = "/api/get-pose/";
        let aiEnabled = false;

        // FACTOR DE EXAGERACIÓN:
        // 1.0 = Movimiento real (1 metro real = 1 unidad 3D)
        // 3.0 = El personaje se mueve 3 veces más que tú (Ideal para recorrer la sala sin moverte tanto)
        const MOVEMENT_MULTIPLIER = 4.0;

        // VELOCIDAD DE REACCIÓN (LERP):
        // 0.1 = Muy suave pero con retardo (como patinando)
        // 0.3 = Rápido y responsivo
        const LERP_SPEED = 0.2;

        // Escena
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf3f4f6);

        // CÁMARA
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 12, 15);

        const renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 0, 0);

        // LUCES
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- CARGA DE MODELOS ---
        const loader = new GLTFLoader();

        // 1. ROOM
        loader.load("{% static 'models/room/scene.glb' %}", function (gltf) {
            const model = gltf.scene;
            model.rotation.x = -Math.PI / 2;
            model.traverse((node) => {
                if (node.isMesh) node.receiveShadow = true;
            });
            scene.add(model);
        });

        // --- VARIABLES PERSONAJE ---
        let characterMesh;
        let bones = {};

        const BONE_MAP = {
            rightShoulder: ['RightArm', 'mixamorigRightArm'],
            rightElbow: ['RightForeArm', 'mixamorigRightForeArm'],
            leftShoulder: ['LeftArm', 'mixamorigLeftArm'],
            leftElbow: ['LeftForeArm', 'mixamorigLeftForeArm'],
            rightHip: ['RightUpLeg', 'mixamorigRightUpLeg'],
            rightKnee: ['RightLeg', 'mixamorigRightLeg'],
            leftHip: ['LeftUpLeg', 'mixamorigLeftUpLeg'],
            leftKnee: ['LeftLeg', 'mixamorigLeftLeg']
        };

        // --- NUEVA FUNCIÓN: POSE FIJA ---
        function setFixedPose() {
            // Verificamos si los huesos están cargados
            if (Object.keys(bones).length === 0) return;

            // 1. PIERNAS SEPARADAS (Rotación en Z hacia afuera)
            if (bones.rightHip) bones.rightHip.rotation.z = -0; // -17 grados aprox
            if (bones.leftHip) bones.leftHip.rotation.z = 0;    // +17 grados aprox

            // 2. BRAZO DERECHO ARRIBA (Vertical)
            if (bones.rightShoulder) {
                // En Mixamo, Z controla la elevación. PI es 180 grados.
                bones.rightShoulder.rotation.z = 1;
                bones.rightShoulder.rotation.x = 1.57; // 90 grados hacia arriba
                bones.rightShoulder.rotation.y = 0;
            }

            // Estirar codo derecho
            if (bones.rightElbow) bones.rightElbow.rotation.set(-20, 10, 0);

            // 3. BRAZO IZQUIERDO HACIA ADELANTE (Horizontal)
            if (bones.leftShoulder) {
                // Z = 0 (Altura del hombro)
                // Y = PI/2 (90 grados hacia el frente)
                bones.leftShoulder.rotation.z = 0;
                bones.leftShoulder.rotation.y = 0;
                bones.leftShoulder.rotation.x = 0;
            }

            // Estirar codo izquierdo
            if (bones.leftElbow) bones.leftElbow.rotation.set(0, 0, 0);
        }

        // 2. PERSONAJE
        loader.load("{% static 'models/caracter/personaje.glb' %}", function (gltf) {
            characterMesh = gltf.scene;
            characterMesh.position.set(0, 0, 0);
            characterMesh.scale.set(3, 3, 3);

            characterMesh.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
                if (node.isBone) {
                    for (const [key, names] of Object.entries(BONE_MAP)) {
                        if (names.some(n => node.name.includes(n))) bones[key] = node;
                    }
                }
            });
            scene.add(characterMesh);

            // !!! APLICAMOS LA POSE NADA MÁS CARGAR !!!
            setFixedPose();
        });

        // --- UI ---
        const toggleAi = document.getElementById('toggle-ai');
        const statusText = document.getElementById('status-text');
        const debugData = document.getElementById('debug-data');

        toggleAi.addEventListener('change', (e) => {
            aiEnabled = e.target.checked;
            if (aiEnabled) {
                statusText.innerText = "Conectando...";
                statusText.className = "font-bold text-green-600";
            } else {
                statusText.innerText = "Inactivo (Pose Fija)";
                statusText.className = "font-bold text-gray-600";
                // !!! SI APAGAMOS LA IA, RESTAURAMOS LA POSE FIJA !!!
                setFixedPose();
            }
        });

        // --- LÓGICA MATEMÁTICA (IA) ---

        function updateArm(bone, ptParent, ptChild, isLeftArmOfCharacter) {
            if (!bone || !ptParent || !ptChild) return;

            let dx = ptChild.x - ptParent.x;
            let dy = ptChild.y - ptParent.y;

            if (!isLeftArmOfCharacter) {
                dx = -dx;
            }

            const angle = Math.atan2(-dy, dx);

            if (isLeftArmOfCharacter) {
                bone.rotation.z = angle + Math.PI / 2;
            } else {
                bone.rotation.z = angle - Math.PI / 2;
            }

            bone.rotation.x = 0;
            bone.rotation.y = 0;
        }

        function updateLegSafe(bone, ptParent, ptChild, isLeftLegOfCharacter) {
            if (!bone || !ptParent || !ptChild) return;

            let dx = ptChild.x - ptParent.x;
            if (!isLeftLegOfCharacter) dx = -dx;

            const rotZ = -dx * 1.5;
            bone.rotation.z = Math.max(-0.5, Math.min(0.5, rotZ));

            bone.rotation.x = 0;
            bone.rotation.y = 0;
        }

        async function updatePose() {
            if (!aiEnabled || !characterMesh) return;

            try {
                const res = await fetch(API_URL);
                const data = await res.json();

                debugData.innerText = JSON.stringify(data, null, 2);

                // --- AQUÍ ESTÁ EL CAMBIO ---
                if (data.position) {
                    // 1. Convertimos CM a Metros
                    let rawX = data.position.x / 100;
                    let rawZ = data.position.y / 100;

                    // 2. Aplicamos el MULTIPLICADOR para exagerar el movimiento
                    // Esto hace que un paso pequeño tuyo sea un paso grande del avatar
                    let targetX = rawX * MOVEMENT_MULTIPLIER;
                    let targetZ = rawZ * MOVEMENT_MULTIPLIER;

                    // 3. INTERPOLACIÓN (LERP)
                    // Usamos LERP_SPEED para controlar la suavidad vs rapidez
                    characterMesh.position.x += (targetX - characterMesh.position.x) * LERP_SPEED;
                    characterMesh.position.z += (targetZ - characterMesh.position.z) * LERP_SPEED;

                    // Mantener altura 0
                    characterMesh.position.y = 0;
                }
                // ---------------------------

                if (data.extremities) {
                    // ... (tu código de huesos sigue igual)
                }

            } catch (e) {
                debugData.innerText = "Error: " + e.message;
            }
        }

        setInterval(updatePose, 50);

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        animate();
    </script>
{% endblock content %}