{% extends "base.html" %}
{% load static %}

{% block content %}

    <div class="relative w-full h-screen bg-gray-100">
        <div id="canvas-container" class="w-full h-full block"></div>

        <div class="absolute top-4 left-4 p-4 bg-white/90 rounded-lg shadow-lg backdrop-blur-sm z-10 w-80">
            <h1 class="text-xl font-bold text-gray-800">Operations Center</h1>
            <div class="flex justify-between items-center mb-4">
                <p class="text-sm text-gray-600">Status: <span id="status-text" class="font-bold text-blue-600">Waiting...</span>
                </p>
                <label class="inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggle-ai" class="sr-only peer">
                    <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    <span class="ms-3 text-sm font-medium text-gray-900">Activate AI</span>
                </label>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';
        import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

        // --- CONFIGURACI칍N ---
        const API_URL = "/api/get-pose/";
        let aiEnabled = false;

        const MOVEMENT_MULTIPLIER = 4.0;
        const LERP_SPEED = 0.1;
        const WALKING_THRESHOLD = 1.5;

        // Escena
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xbc8a5a);
        const clock = new THREE.Clock();

        // C치mara
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 12, 15);

        const renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 0, 0);

        // Luces
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- GESTI칍N DE ANIMACIONES ---
        let mixer;
        let actions = {};
        let activeAction;
        let currentTargetX = 0;
        let currentTargetZ = 0;
        let currentBackendState = "normal"; // Estado recibido del backend

        function fadeToAction(name, duration) {
            // Si la animaci칩n no existe o ya es la activa, no hacemos nada
            if (!actions[name] || activeAction === actions[name]) return;

            const previousAction = activeAction;
            activeAction = actions[name];

            if (previousAction) {
                previousAction.fadeOut(duration);
            }

            activeAction
                .reset()
                .setEffectiveTimeScale(1)
                .setEffectiveWeight(1)
                .fadeIn(duration)
                .play();
        }

        // --- CARGA DE MODELOS ---
        const loader = new GLTFLoader();
        let characterMesh;

        // 1. ROOM (ESCENARIO - DIN츼MICO)
        // Usamos la variable selected_stage
        const roomConfigUrl = "{% static 'models/room/' %}{{ selected_stage }}_config.json";
        const roomModelUrl = "{% static 'models/room/' %}{{ selected_stage }}.glb";

        async function loadRoom() {
            try {
                // A. Cargamos la configuraci칩n
                const response = await fetch(roomConfigUrl);
                if (!response.ok) throw new Error("No se pudo cargar config del escenario");
                const config = await response.json();

                // --- NUEVO: APLICAR COLOR DE FONDO ---
                if (config.background_color) {
                    scene.background = new THREE.Color(config.background_color);
                }
                // -------------------------------------

                // B. Cargamos el modelo
                loader.load(roomModelUrl, function (gltf) {
                    const model = gltf.scene;

                    // C. Aplicamos transformaciones del JSON
                    if (config.scale) {
                        model.scale.set(config.scale.x, config.scale.y, config.scale.z);
                    }
                    if (config.position) {
                        model.position.set(config.position.x, config.position.y, config.position.z);
                    }
                    if (config.rotation) {
                        model.rotation.set(config.rotation.x, config.rotation.y, config.rotation.z);
                    }

                    // D. Sombras y a침adir a escena
                    model.traverse((node) => {
                        if (node.isMesh) node.receiveShadow = true;
                    });

                    scene.add(model);
                    console.log("--- ESCENARIO {{ selected_stage }} CARGADO ---");
                });

            } catch (error) {
                console.error("Error cargando config:", error);
                // Fallback: Carga b치sica si falla el JSON (Intenta cargar el modelo sin config)
                loader.load(roomModelUrl, function (gltf) {
                    const model = gltf.scene;
                    model.scale.set(3, 3, 3);
                    model.rotation.x = -Math.PI / 2;
                    scene.add(model);
                });
            }
        }

        // Ejecutar la carga
        loadRoom();

        // 2. PERSONAJE (DIN츼MICO)
        // Usamos la variable selected_character
        const characterBaseUrl = "{% static 'models/caracter/' %}{{ selected_character }}/";

        loader.load(characterBaseUrl + "idle.glb", function (gltf) {
            console.log("--- PERSONAJE {{ selected_character }} CARGADO ---");
            characterMesh = gltf.scene;

            characterMesh.position.set(0, 0, 0);
            characterMesh.scale.set(3, 3, 3);

            characterMesh.traverse((node) => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            scene.add(characterMesh);

            mixer = new THREE.AnimationMixer(characterMesh);

            // 2.1 ANIMACI칍N: AWAITING (Base)
            if (gltf.animations.length > 0) {
                const clip = gltf.animations[0];
                const action = mixer.clipAction(clip);
                actions['awaiting'] = action;
                activeAction = action;
                action.play();
            }

            // 2.2 ANIMACI칍N: WALKING
            loader.load(characterBaseUrl + "walking.glb", function (animGltf) {
                if (animGltf.animations.length > 0) {
                    const clip = animGltf.animations[0];
                    const action = mixer.clipAction(clip);
                    actions['walking'] = action;
                }
            });

            // 2.3 ANIMACI칍N: WAVING
            loader.load(characterBaseUrl + "waving.glb", function (animGltf) {
                if (animGltf.animations.length > 0) {
                    console.log("Animaci칩n Waving cargada");
                    const clip = animGltf.animations[0];
                    const action = mixer.clipAction(clip);
                    actions['waving'] = action;
                }
            });
        });

        // --- UI ---
        const toggleAi = document.getElementById('toggle-ai');
        const statusText = document.getElementById('status-text');

        // ELIMINADO: debug-data no existe en el HTML, lo comentamos para evitar errores
        // const debugData = document.getElementById('debug-data');

        toggleAi.addEventListener('change', (e) => {
            aiEnabled = e.target.checked;
            statusText.innerText = aiEnabled ? "Conectando..." : "Inactivo";
            statusText.className = aiEnabled ? "font-bold text-green-600" : "font-bold text-gray-600";
            if (!aiEnabled && actions['awaiting']) {
                fadeToAction('awaiting', 0.5);
            }
        });

        async function updatePose() {
            if (!aiEnabled || !characterMesh) return;
            try {
                const res = await fetch(API_URL);
                const data = await res.json();

                console.log("游니 API Response:", data);

                // ELIMINADO para evitar crash:
                // debugData.innerText = JSON.stringify(data, null, 2);

                if (data.position) {
                    let rawX = data.position.x / 100;
                    let rawZ = data.position.y / 100;
                    currentTargetX = rawX * MOVEMENT_MULTIPLIER;
                    currentTargetZ = rawZ * MOVEMENT_MULTIPLIER;
                }

                // LEER ESTADO (WAVING / NORMAL)
                if (data.state) {
                    currentBackendState = data.state;
                }

            } catch (e) {
                console.error(e);
                // ELIMINADO para evitar crash:
                // debugData.innerText = "Error: " + e.message;
            }
        }

        setInterval(updatePose, 50);

        // --- LOOP PRINCIPAL ---
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            if (mixer) mixer.update(dt);

            if (characterMesh && aiEnabled) {
                // C치lculo de movimiento f칤sico (siempre activo para que no se teletransporte)
                const currentX = characterMesh.position.x;
                const currentZ = characterMesh.position.z;

                // Movimiento f칤sico del personaje (interpolaci칩n)
                characterMesh.position.x += (currentTargetX - currentX) * LERP_SPEED;
                characterMesh.position.z += (currentTargetZ - currentZ) * LERP_SPEED;
                characterMesh.position.y = 0;

                const distX = currentTargetX - characterMesh.position.x;
                const distZ = currentTargetZ - characterMesh.position.z;
                const distanceToTarget = Math.sqrt(distX * distX + distZ * distZ);

                // Rotaci칩n (LookAt)
                if (distanceToTarget > 0.1) {
                    const lookTarget = new THREE.Vector3(currentTargetX, 0, currentTargetZ);
                    characterMesh.lookAt(lookTarget);
                }

                // --- M츼QUINA DE ESTADOS (PRIORIDADES) ---

                // 1. PRIORIDAD M츼XIMA: WAVING
                if (currentBackendState === 'waving') {
                    fadeToAction('waving', 0.2);
                }
                // 2. PRIORIDAD MEDIA: WALKING
                else if (distanceToTarget > WALKING_THRESHOLD) {
                    fadeToAction('walking', 0.2);
                }
                // 3. PRIORIDAD BAJA: AWAITING
                else {
                    fadeToAction('awaiting', 0.2);
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        animate();
    </script>
{% endblock content %}